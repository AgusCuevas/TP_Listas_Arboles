# -*- coding: utf-8 -*-
"""TP_listasArboles_1cuat_2021

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-ZRb0r0rw3Wab2L0clQGxkalNVW07DSh

### **TDAs Listas y Arboles**
"""

from graphviz import Digraph

    ######################################### NODO LISTAS ENLAZADAS ###################################

class NodoLista:
  def __init__(self, dato = None):
    self.dato = dato
    self.siguiente = None

  def tieneSiguiente(self):
    return self.siguiente != None

  def append(self, dato):
    nodoNuevo = NodoLista(dato)
    if (not self.tieneSiguiente()):
      self.siguiente = nodoNuevo
    else:
      self.siguiente.append(dato)

  def len(self):
    cant = 1
    if (self.tieneSiguiente()):
      cant += self.siguiente.len()
    return cant

  def insertar(self, nodoNuevo, pos, posAct = 0):
    if (pos - 1 == posAct):
      nodoNuevo.siguiente = self.siguiente
      self.siguiente = nodoNuevo
    elif (not self.tieneSiguiente()):
      self.siguiente = nodoNuevo
    else:
      self.siguiente.insertar(nodoNuevo, posAct + 1)

  def obtener(self, getPos, posAct = 0):
    if (getPos == posAct):
      return self.dato
    else:
      self.siguiente.obtener(getPos, posAct + 1)

  def eliminar(self, posElim, posAct = 0):
    if (posElim - 1 == posAct):
      self.siguiente = self.siguiente.siguiente
    else:
      self.siguiente.eliminar(posElim, posAct + 1)


  def clonar(self, listaClon):
    if (not self.tieneSiguiente()):
      listaClon.append(self.dato)
    else:
      listaClon.append(self.dato)
      self.siguiente.clonar(listaClon)

  def buscaElemento(self, elemento):
    encontrado = False
    if (not self.tieneSiguiente()):
      if (self.dato == elemento):
        encontrado = True
        return encontrado
    elif (self.dato == elemento):
      encontrado = True
      return encontrado
      encontrado = self.siguiente.buscaElemento(elemento)
    else:
      encontrado = self.siguiente.buscaElemento(elemento)
    return encontrado


  def get(self, posDato):
    if 0 <= posDato < self.len():
      posActual = 0
      actual = self
      while posActual < posDato:
        actual = actual.siguiente
        posActual += 1
      return actual.dato
    else:
      raise Exception("Posicion incorrecta")

  def posicionElemento(self, elemento, posiciones, posAct = 0):
    if (not self.tieneSiguiente()):
      if (self.dato == elemento):
        nodo = NodoLista(posAct)
        posiciones.append(nodo.dato)
    elif (self.dato == elemento):
      nodo = NodoLista(posAct)
      posiciones.append(nodo.dato)
      self.siguiente.posicionElemento(elemento, posiciones, posAct + 1)
    else:
      self.siguiente.posicionElemento(elemento, posiciones, posAct + 1)

    ################################ LISTA ENLAZADA ############################################

class Lista:
  def __init__(self):
    self.primero = None

  def estaVacia(self):
    return self.primero == None

  def vaciar(self):
    self.primero = None

  def append(self, dato):
    nodoNuevo = NodoLista(dato)
    if (self.estaVacia()):
      self.primero = nodoNuevo
    else:
      self.primero.append(dato)
    
  def len(self):
    contador = 0
    if (not self.estaVacia()):
      contador = self.primero.len()
    return contador

  def insertar(self, dato, pos):
    nodoNuevo = NodoLista(dato)
    if (self.estaVacia()):
      self.primero = nodoNuevo
    else:
      self.primero.insertar(nodoNuevo, pos)

  def obtener(self, pos):
    dato = None
    if (0 <= pos < self.len() and not self.estaVacia()):
      dato = self.primero.obtener(pos)
    return dato

  def eliminar(self, posElim):
    if (0 <= posElim < self.len() and not self.estaVacia()):
      if (posElim == 0):
        self.primero = self.primero.siguiente
      else:
        self.primero.eliminar(posElim)

  def clonar(self):
    listaClon = Lista()
    if (not self.estaVacia()):
      self.primero.clonar(listaClon)
    return listaClon

  def buscaElemento(self, elemento):
    encontrado = False 
    if (not self.estaVacia()):
      encontrado = self.primero.buscaElemento(elemento)
    else:
      raise Exception("La lista esta vacia")
    return encontrado

  def get(self, posDato):
    dato = None
    if not self.estaVacia() and 0 <= posDato < self.len():
      dato = self.primero.get(posDato)
    else:
      raise Exception("Posicion incorrecta")
    return dato

  def posicionElemento(self, elemento):
    posiciones = Lista()
    if (not self.estaVacia()):
      self.primero.posicionElemento(elemento, posiciones)
    else:
      raise Exception("La lista esta vacia")
    return posiciones.get(0)

  def __repr__(self):
    strOut = ""
    aux = self.primero
    while aux != None:
      strOut = strOut + " -> " + str(aux.dato)
      aux = aux.siguiente
    strOut = strOut + " -|"
    return strOut

    ######################################### NODO ARBOL ###################################

class NodoArbolDeLibros:
  def __init__(self, autor = None):
    self.autor = autor
    self.izquierdo = None
    self.derecho = None
    self.libros = Lista()

  def tieneDerecho(self):
    return self.derecho != None
  def tieneIzquierdo(self):
    return self.izquierdo != None

  def treePlot(self, dot):
    if self.tieneIzquierdo():
      dot.node(str(self.izquierdo.autor), str(self.izquierdo.autor)+"\n"+str(self.izquierdo.libros))
      dot.edge(str(self.autor), str(self.izquierdo.autor))
      self.izquierdo.treePlot(dot)
    else:
      dot.node("None"+str(self.autor)+"l", "None")
      dot.edge(str(self.autor), "None"+str(self.autor)+"l")
    if self.tieneDerecho():
      dot.node(str(self.derecho.autor), str(self.derecho.autor)+"\n"+str(self.derecho.libros))
      dot.edge(str(self.autor), str(self.derecho.autor))
      self.derecho.treePlot(dot)
    else:
      dot.node("None"+str(self.autor)+"r", "None")
      dot.edge(str(self.autor), "None"+str(self.autor)+"r")

  def obtenerGrado(self):
    grado = 0
    if ( self.tieneDerecho()):
      grado += 1
    if (self.tieneIzquierdo()):
      grado += 1
    return grado  

  def esHoja(self):
    return not self.tieneDerecho() and not self.tieneIzquierdo()

  def predecesor(self):
    prede = None
    if (self.tieneIzquierdo):
      prede = self.izquierdo.obtenerMaximo()
    return prede 

  def sucesor(self):
    sucesor = None
    if (self.tieneDerecho):
      sucesor = self.derecho.obtenerMinimo()
    return sucesor  

  def mostrarPreOrden(self):
    print(self.autor)
    if (self.tieneIzquierdo()):
      self.izquierdo.mostrarPreOrden()
    if (self.tieneDerecho()):
      self.derecho.mostrarPreOrden()

  def mostrarInOrden(self):
    if (self.tieneIzquierdo()):
      self.izquierdo.mostrarInOrden()
    print(self.autor)
    if (self.tieneDerecho()):
      self.derecho.mostrarInOrden()

  def mostrarPosOrden(self):
    if (self.tieneIzquierdo()):
      self.izquierdo.mostrarPosOrden()
    if (self.tieneDerecho()):
      self.derecho.mostrarPosOrden()
    print(self.autor)
  
  def insertar(self, autor):
    nodoNuevo = NodoArbolDeLibros(autor)
    if str(nodoNuevo.autor) < str(self.autor):
      if self.tieneIzquierdo():
        self.izquierdo.insertar(autor)
      else:
        self.izquierdo = nodoNuevo
    elif str(nodoNuevo.autor) > str(self.autor):
      if self.tieneDerecho():
        self.derecho.insertar(autor)
      else:
        self.derecho = nodoNuevo

  def buscar(self, autor):
    nodoABuscar = None
    if autor == self.autor:
      nodoABuscar = self
    elif autor < str(self.autor):
      if self.tieneIzquierdo():
        nodoABuscar = self.izquierdo.buscar(autor)
    else:
      if self.tieneDerecho():
        nodoABuscar = self.derecho.buscar(autor)
    return nodoABuscar

  def pesoDelArbol(self):
    cont = 1
    if (self.tieneIzquierdo()):
      cont += self.izquierdo.pesoDelArbol()
    if (self.tieneDerecho()):
      cont += self.derecho.pesoDelArbol()
    return cont 

  def obtenerMinimo(self):
    minimo = None 
    if (self.tieneIzquierdo()):
      minimo = self.izquierdo.obtenerMinimo()
    else:
      minimo = self
    return minimo

  def obtenerMaximo(self):
    maximo = None
    if (self.tieneDerecho()):
      maximo = self.derecho.obtenerMaximo()
    else:
      maximo = self
    return maximo

  def altura(self):
    altura = 0
    if (self.esHoja()):
      altura = 0
    else:
      if (self.tieneIzquierdo() and self.tieneDerecho()):
        altura = 1 + max(self.izquierdo.altura(), self.derecho.altura())
      elif (self.tieneIzquierdo()):
        altura = 1 + self.izquierdo.altura()
      else:
        altura = 1 + self.derecho.altura()
    return altura

    ######################################### ARBOL BINARIO BUSQUEDA ###################################

class ArbolDeLibros:
  def __init__(self):
    self.raiz = None
  
  def treePlot(self, fileName='tree'):
    if not self.estaVacio():
      treeDot = Digraph()
      treeDot.node(str(self.raiz.autor), str(self.raiz.autor)+"\n"+str(self.raiz.libros))
      self.raiz.treePlot(treeDot)
      treeDot.render(fileName, view=True)
      
  def estaVacio(self):
    self.raiz == None
  
  def vaciar(self):
    if (self.estaVacio()):
      print('El arbol esta vacio')
    else:
      self.raiz = None 

  def mostrarPreOrden(self):
    if (not self.estaVacio()):
      self.raiz.mostrarPreOrden()

  def mostrarInOrden(self):
    if (not self.estaVacio()):
      self.raiz.mostrarInOrden()

  def mostrarPosOrden(self):
    if (not self.estaVacio()):
      self.raiz.mostrarPosOrden()

  def insertar(self, autor):
    nuevoNodo = NodoArbolDeLibros(autor)
    if (self.raiz == None):
      self.raiz = nuevoNodo
    else:
      self.raiz.insertar(autor)

  def buscar(self, autor):
    estaEnArbol = False
    if not self.estaVacio():
      estaEnArbol = self.raiz.buscar(autor) != None
    return estaEnArbol

  def pesoDelArbol(self):
    peso = 0
    if (not self.estaVacio()):
      peso = self.raiz.pesoDelArbol()
    return peso 

  def obtenerMinimo(self):
    minimo = None
    if (not self.estaVacio()):
      minimo = self.raiz.obtenerMinimo().autor
    return minimo

  def obtenerMaximo(self):
    maximo = None
    if (not self.estaVacio()):
      maximo = self.raiz.obtenerMaximo().autor
    return maximo
  
  def altura(self):
    altura = 0
    if (not self.estaVacio()):
      altura = self.raiz.altura()
    return altura

"""## ***insertarLibros(listaLibros, nombreAutor):***"""

class NodoLista(NodoLista):
  # Verifica que el libro pasado por parametro no este repetido en la lista
  def libroRepetido(self,libro, repetido):
    if (self.dato == libro):
      repetido = True
    elif (self.tieneSiguiente()):
      self.siguiente.libroRepetido(libro, repetido)
    return repetido
      

class Lista(Lista):
  # Nombre: libroRepetido
  # Parametros: libro -> libro
  # Que hace: Verifica que el libro pasado por parametro este repetido en la lista
  # Devuelve: Booleano
  def libroRepetido(self, libro):
    repetido = False
    if (self.estaVacia):
      return repetido
    else:
      self.primero.libroRepetido(libro, repetido)
      return repetido
  
  # Nombre: agregarLibros
  # Parametros: libros -> Lista de libros
  # Que hace: Agrega todos los libros de la lista pasada por parametro, menos los libros repetidos
  # Devuelve: Nada
  def agregarLibros(self, libros):
    while (not libros.estaVacia()):
      if (self.libroRepetido(libros.obtener(0))):
        libros.eliminar(0)
      else:
        self.append(libros.obtener(0))
        libros.eliminar(0)
  

class NodoArbolDeLibros(NodoArbolDeLibros):
  # Inserta una lista de libros pasada por parametros en el nodo que tenga el mismo nombre del autor pasado por parametro
  # En caso de que no exista en el arbol se crea un nuevo nodo con el nombre del autor pasado por parametro
  def insertarLibros(self, listaLibros, nombreAutor):
    if (self.autor == nombreAutor):
      self.libros.agregarLibros(listaLibros)
    if (self.tieneIzquierdo()):
      self.izquierdo.insertarLibros(listaLibros, nombreAutor)
    if (self.tieneDerecho()):
      self.derecho.insertarLibros(listaLibros, nombreAutor)

class ArbolDeLibros(ArbolDeLibros): 
  # Nombre: insertarLibros
  # Parametros: listaLibros -> Lista de libros, nombreAutor -> string 
  # Que hace: Inserta una lista de libros pasada por parametros en el nodo que tenga el mismo nombre del autor pasado por parametro
  # En caso de que no exista en el arbol se crea un nuevo nodo con el nombre del autor pasado por parametro
  def insertarLibros(self, listaLibros, nombreAutor):
    self.insertar(nombreAutor)
    if (not self.estaVacio()):
      if (self.raiz.autor == nombreAutor):
        self.raiz.libros.agregarLibros(listaLibros)
      else:
        self.raiz.insertarLibros(listaLibros, nombreAutor)

archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()

################################################################################
################################################################################

arbolDeLibrosTest.treePlot("arbolCompleto")

"""## ***autoresConPalabraEnTitulo(palabra):***"""

class NodoLista(NodoLista):
  def buscarPalabraEnLista(self, palabra):
    contador = 0
    if (self.dato.count(palabra) > 0):
      contador += 1
    if (self.tieneSiguiente()):
      contador += self.siguiente.buscarPalabraEnLista(palabra)
    return contador > 0

class Lista(Lista):
  # Nombre: buscarPalabraEnLista
  # Parametros: palabra -> string
  # Que hace: Busca la palabra en la lista
  # Devuelve: Booleano
  def buscarPalabraEnLista(self, palabra):
    estaPalabra = False
    if (not self.estaVacia()):
      if (self.primero.dato.count(palabra)>0):
        estaPalabra = True
      else:
        estaPalabra = self.primero.buscarPalabraEnLista(palabra)
    return estaPalabra

class NodoArbolDeLibros(NodoArbolDeLibros):
  def autoresConPalabraEnTitulo(self, palabra, listaDeAutores):
    if (self.libros.buscarPalabraEnLista(palabra)):
      listaDeAutores.append(self.autor)
    if (self.tieneIzquierdo()):
      self.izquierdo.autoresConPalabraEnTitulo(palabra, listaDeAutores)
    if (self.tieneDerecho()):
      self.derecho.autoresConPalabraEnTitulo(palabra, listaDeAutores)

class ArbolDeLibros(ArbolDeLibros):
  # Nombre: autoresConPalabraEnTitulo
  # Parametros: palabra -> string
  # Que hace: Busca los autores que en cualquiera de sus libros el titulo contenga la palabra pasada por parametro
  # Devuelve: Lista de autores
  def autoresConPalabraEnTitulo(self, palabra):
    listaDeAutores = Lista()
    if (not self.estaVacio()):
      self.raiz.autoresConPalabraEnTitulo(palabra, listaDeAutores)
    return listaDeAutores

archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()

print(arbolDeLibrosTest.raiz.libros.primero.dato)
print(arbolDeLibrosTest.raiz.libros.primero.dato.count('vs'))
print(arbolDeLibrosTest.raiz.libros.buscarPalabraEnLista('vs'))
print(arbolDeLibrosTest.raiz.izquierdo.libros.buscarPalabraEnLista('rayo'))
print(arbolDeLibrosTest.autoresConPalabraEnTitulo('rayo'))

print("\n#################PRUEBA DE OPERACION autoresConPalabraEnTitulo##################")
print("\nBúsqueda de palabras que no existen en ningun título de libro:")
palabrasNoEstan = ["puerta","casa","feliz"]
for palabra in palabrasNoEstan:
  print("Autor de libro con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))

print("\nBúsqueda de palabras que están en el árbol en un único título de libro:")
palabrasTituloUnico = ["armar","llano","vigilia"]
for palabra in palabrasTituloUnico:
  print("Autor de libro con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))

print("\nBúsqueda de palabras que están en el árbol en varios títulos de libros:")
palabrasTituloVarios = ["camino","isla","mundo"]
for palabra in palabrasTituloVarios:
  print("Autores de libros con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))

"""## ***buscarLibros(listaAutores):***"""

class NodoLista(NodoLista):
  def interseccion(self, otraLista, inter):
    if (otraLista.buscarPalabraEnLista(self.dato)):
      inter.append(self.dato)
    if (self.tieneSiguiente()):
      self.siguiente.interseccion(otraLista, inter)

class Lista(Lista):
  # Nombre: reemplazar
  # Parametros: listaNueva -> lista la cual queremos copiar
  # Que hace: Copia la lista por parametros
  # Devuelve: Nada
  def reemplazar(self, listaNueva):
    self.vaciar()
    clon = listaNueva.clonar()
    while (not clon.estaVacia()):
      self.append(clon.get(0))
      clon.eliminar(0)

  # Retorna una lista con los elementos compartidos por ambas listas
  # Nombre: interseccion 
  # Parametros: otraLista -> Lista
  # Que hace: Busca elementos que se en ambas listas
  # Devuelve: Una lista con todos los elementos compartidos por ambas listas
  def interseccion(self, otraLista):
    inter = Lista()
    if (not self.estaVacia() and not otraLista.estaVacia()):
      self.primero.interseccion(otraLista, inter)
    return self.reemplazar(inter)

  
class NodoArbolDeLibros(NodoArbolDeLibros):
  def buscarLibros(self, listaAutores, listaInterseccion = Lista()):
    if (listaInterseccion.estaVacia()):
      if (listaAutores.buscarPalabraEnLista(self.autor)):
        listaInterseccion.reemplazar(self.libros)
      if (self.tieneIzquierdo()):
        self.izquierdo.buscarLibros(listaAutores, listaInterseccion)
      if (self.tieneDerecho()):
        self.derecho.buscarLibros(listaAutores, listaInterseccion)
    else:
      if (listaAutores.buscarPalabraEnLista(self.autor)):
        listaInterseccion.interseccion(self.libros)
      if (self.tieneIzquierdo()):
        self.izquierdo.buscarLibros(listaAutores, listaInterseccion)
      if (self.tieneDerecho()):
        self.derecho.buscarLibros(listaAutores, listaInterseccion)

class ArbolDeLibros(ArbolDeLibros):
  # Nombre: buscarLibros
  # Parametros: listaAutores -> Lista de autores 
  # Que hace: Busca libros compartidos por todos los autores pasados por parametros 
  # Devuelve: Una lista de los libros compartidos por todos los autores
  def buscarLibros(self, listaAutores):
    listaInterseccion = Lista()
    if (not self.estaVacio() and not listaAutores.estaVacia()):
      if (listaAutores.buscarPalabraEnLista(self.raiz.autor)):
        listaInterseccion = self.raiz.libros.clonar()
      else:
       self.raiz.buscarLibros(listaAutores, listaInterseccion)
    return listaInterseccion


#############CARGA DE ARBOL Y GENERACION DE VARIABLES PARA LA PRUEBA############

archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()

######################PRUEBA DE OPERACION buscarLibros##########################

print("\n######################PRUEBA DE OPERACION buscarLibros##########################")
print("\nBúsqueda de autores/as que no existen en el árbol:")
autoresNoEstan = ["Eduardo Sacheri","Victoria Ocampo","Jane Austen"]
for autor in autoresNoEstan:
  listaAutores = Lista()
  listaAutores.append(autor)
  print("Libros de",autor,"en el árbol:",arbolDeLibrosTest.buscarLibros(listaAutores))

print("\nBúsqueda de autores/as que están en el arbol pero no comparten libros:")
autoresConDistintas = ["Julio Cortázar","Roberto Fontanarrosa","Oscar Wilde"]
listaAutores = Lista()
print("\nBuscados de a uno:")
for autor in autoresConDistintas:
  listaActual = Lista()
  listaActual.append(autor)
  print("El/La autor/a",autor,"tiene los libros:",arbolDeLibrosTest.buscarLibros(listaActual))
  listaAutores.append(autor)
print("\nLos libros compartidos por",listaAutores,"son:",arbolDeLibrosTest.buscarLibros(listaAutores))

print("\nBúsqueda con autores/as que comparten libros:")
listaPares = [["Jorge Luis Borges","Paulo Coelho"],
              ["Paulo Coelho","Ben Jonson"],
              ["Craig Russell","Leon Tolstoi"],
              ["Michael Crichton","Arthur Conan Doyle"],
              ["Isabel Allende","Rani Manicka"]]
for par in listaPares:
  listaAutores = Lista()
  for autor in par:
    listaAutores.append(autor)
  print("Los libros compartidos por",listaAutores,"son:",arbolDeLibrosTest.buscarLibros(listaAutores))

"""## ***eliminarAutor(autor):***"""

class NodoArbolDeLibros(NodoArbolDeLibros):
  def eliminarAutor(self, autor):
    if autor < self.autor:
      if self.tieneIzquierdo():
        if self.izquierdo.autor == autor:
          if self.izquierdo.obtenerGrado() == 2:
            pred = self.izquierdo.predecesor()
            self.izquierdo.eliminarAutor(pred.autor)
            pred.izquierdo = self.izquierdo.izquierdo
            pred.derecho = self.izquierdo.derecho
            self.izquierdo = pred          
          elif self.izquierdo.obtenerGrado() == 1 and self.izquierdo.tieneIzquierdo():
            self.izquierdo = self.izquierdo.izquierdo
          elif self.izquierdo.obtenerGrado() == 1 and self.izquierdo.tieneDerecho():
            self.izquierdo = self.izquierdo.derecho
          else:
            self.izquierdo = None
        else: 
          self.izquierdo.eliminarAutor(autor)
    else: 
      if self.tieneDerecho():
        if self.derecho.autor == autor:
          if self.derecho.obtenerGrado() == 2:
            pred = self.derecho.predecesor()
            self.derecho.eliminarAutor(pred.autor)
            pred.izquierdo = self.derecho.izquierdo
            pred.derecho = self.derecho.derecho
            self.derecho = pred          
          elif self.derecho.obtenerGrado() == 1 and self.derecho.tieneIzquierdo():
            self.derecho = self.derecho.izquierdo
          elif self.derecho.obtenerGrado() == 1 and self.derecho.tieneDerecho():
            self.derecho = self.derecho.derecho
          else:
            self.derecho  = None
        else: 
          self.derecho.eliminarAutor(autor)

class ArbolDeLibros(ArbolDeLibros):
  # Nombre: eliminarAutor
  # Parametros: autor -> string
  # Que hace: Elimina el autor con nombre autor pasado por parametro , si lo encuentra en el arbol 
  # Devuelve: Nada
  def eliminarAutor(self, autor):
    if not self.estaVacio():
      if self.raiz.autor == autor:
        if self.raiz.obtenerGrado() == 2:
          pred = self.raiz.predecesor()
          self.raiz.eliminarAutor(pred.autor)
          pred.izquierdo = self.raiz.izquierdo
          pred.derecho = self.raiz.derecho
          self.raiz = pred
        elif self.raiz.obtenerGrado() == 1 and self.tieneIzquierdo():
          self.raiz = self.raiz.izquierdo
        elif self.raiz.obtenerGrado() == 1 and self.tieneDerecho():
          self.raiz = self.raiz.derecho
        else:
          self.raiz = None
      else:
        self.raiz.eliminarAutor(autor)

archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()
arbolDeLibrosTest.eliminarAutor('Patricio Rey y sus redonditos de ricota')
arbolDeLibrosTest.treePlot("arbolCompleto")

"""## ***eliminarLibro(tituloLibro):***"""

class Lista(Lista):
  # Nombre: eliminarLibro
  # Parametros: titulo -> string
  # Que hace: Elimina el libro con el titulo 'titulo' pasado por parametro , si lo encuentra en la lista 
  # Devuelve: Nada
  def eliminarLibro(self,titulo):
    if (not self.estaVacia()):
      posicion = self.posicionElemento(titulo)
      if (posicion != None):
        self.eliminar(posicion) 

class NodoArbolDeLibros(NodoArbolDeLibros):
  def eliminarLibro(self,titulo):
    if (self.libros.buscaElemento(titulo)):
      self.libros.eliminarLibro(titulo)
    if (self.tieneIzquierdo()):
      self.izquierdo.eliminarLibro(titulo)
    if (self.tieneDerecho()):
      self.derecho.eliminarLibro(titulo)
      


class ArbolDeLibros(ArbolDeLibros):
  # Nombre: eliminarLibro
  # Parametros: titulo -> string
  # Que hace: Busca el nodo que contenga el titulo dentro de la lista de libros del nodo
  # Devuelve: Nada
  def eliminarLibro(self,titulo):
    if (not self.estaVacio()):
      self.raiz.eliminarLibro(titulo)


archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()
arbolDeLibrosTest.eliminarLibro('Botija rapado')
arbolDeLibrosTest.treePlot("arbolCompleto")

"""## ***cantidadTotalAutores(nombre):***"""

class NodoArbolDeLibros(NodoArbolDeLibros):
  def cantidadTotalAutores(self, nombre, autoresQueCumplen):
    if self.autor.count(nombre) > 0:
      autoresQueCumplen.append(self.autor)
    if self.tieneIzquierdo():
      self.izquierdo.cantidadTotalAutores(nombre, autoresQueCumplen)
    if self.tieneDerecho():
      self.derecho.cantidadTotalAutores(nombre, autoresQueCumplen)
      
class ArbolDeLibros(ArbolDeLibros):
  # Retorna la cantidad de autores con el mismo nombre que el nombre pasado por parametro
  # Nombre: cantidadTotalAutores
  # Parametros: nombre -> string
  # Que hace: Busca autores con el mismo nombre que el 'nombre' pasado por parametro
  # Devuelve: La cantidad de autores que cumplen la condicion 
  def cantidadTotalAutores(self, nombre): 
    autoresQueCumplen = Lista()
    if not self.estaVacio():
      self.raiz.cantidadTotalAutores(nombre, autoresQueCumplen)
    return autoresQueCumplen.len()

"""## ***raizBalanceada():***"""

class ArbolDeLibros(ArbolDeLibros):
  # Retorna verdadero si la diferencia de altura entre los nodos hijos izquierdo y derecho es menor o igual a 1 
  # Nombre: raizBalanceada
  # Parametros: 
  # Que hace: Calcula si la diferencia de altura entre los nodos hijos izquierdo y derecho es menor o igual a 1
  # Devuelve: Booleano
  def raizBalanceada(self):
    izq = 0
    der = 0
    esBalanceada = False
    if ( not self.estaVacio() ):
      if (self.raiz.tieneDerecho and not self.raiz.tieneIzquierdo):
        if (self.raiz.derecho.altura <= 1):
          esBalanceada = True
      if (self.raiz.tieneIzquierdo and not self.raiz.tieneDerecho):
        if (self.raiz.izquierdo.altura <= 1):
          esBalanceada = True
      if (self.raiz.tieneDerecho and self.raiz.tieneIzquierdo):
        der = self.raiz.derecho.altura()
        izq = self.raiz.izquierdo.altura()
        resultado = der - izq
        if (resultado == 1 or resultado == 0 or resultado == -1):
          esBalanceada = True
    return esBalanceada

"""## ***librosEnNivel(nivel):***"""

class NodoArbolDeLibros(NodoArbolDeLibros):
  def librosEnNivel(self, nivel, listaNivel, ubicacionNodo = 0):
    if ubicacionNodo == nivel:
      listaNivel.append(self.libros)
    else:
      if self.tieneIzquierdo():
        self.izquierdo.librosEnNivel(nivel, listaNivel,ubicacionNodo+1)
      if self.tieneDerecho():
        self.derecho.librosEnNivel(nivel, listaNivel,ubicacionNodo+1)

class ArbolDeLibros(ArbolDeLibros):
  # Nombre: librosEnNivel
  # Parametros: nivel = Numero
  # Que hace: Busca los nodos que se encuentren en el nivel 'nivel' pasado por parametro
  # Devuelve: Devuelve todos los libros en los cuales el nodo se encuentra en el nivel 'nivel'. Lista de libros
  def librosEnNivel(self, nivel):
    listaNivel = Lista()
    if not self.estaVacio():
      self.raiz.librosEnNivel(nivel, listaNivel)
    return listaNivel

"""## ***autoresConMasLibros(cantidadMinimaLibros):***"""

class NodoArbolDeLibros(NodoArbolDeLibros):
  def autoresConMasLibros(self,cantidadMinimaLibros,autoresQueCumplen):
    if self.libros.len() > cantidadMinimaLibros:
      autoresQueCumplen.append(self.autor)
    if self.tieneIzquierdo():
      self.izquierdo.autoresConMasLibros(cantidadMinimaLibros, autoresQueCumplen)
    if self.tieneDerecho():
      self.derecho.autoresConMasLibros(cantidadMinimaLibros, autoresQueCumplen)



class ArbolDeLibros(ArbolDeLibros):
  # Retorna la cantidad de autores que tengan mas libros que la cantidadMinimaLibros pasada por parametro
  # Nombre: autoresConMasLibros
  # Parametros: cantidadMinimaLibros = Numero
  # Que hace: Busca cantidad de autores que tengan mas libros que la cantidadMinimaLibros pasada por parametro
  # Devuelve: Cantidad de nodos que cumplen la condicion
  def autoresConMasLibros(self,cantidadMinimaLibros):
    autoresQueCumplen = Lista()
    if not self.estaVacio():
      self.raiz.autoresConMasLibros(cantidadMinimaLibros,autoresQueCumplen)
    return autoresQueCumplen.len()

"""## ***internosAlfabetico():***"""

class NodoArbolDeLibros(NodoArbolDeLibros):
  def internosAlfabetico(self,lista):
     if self.tieneIzquierdo():
        self.izquierdo.internosAlfabetico(lista)
     if not self.esHoja():
       lista.append(self.autor)
     if self.tieneDerecho():
        self.derecho.internosAlfabetico(lista)

class ArbolDeLibros(ArbolDeLibros):
  # Nombre: internosAlfabetico
  # Parametros: 
  # Que hace: Busca los autores que su nodos no sean hoja
  # Devuelve: lista de autores en orden alfabetico 
  def internosAlfabetico(self):
    lista = Lista()
    if (not self.estaVacio()):
      self.raiz.internosAlfabetico(lista)
    return lista

"""## ***Script de prueba***

"""

################################################################################
##############################IMPORTANTE!!!!!!##################################
################################################################################

################################################################################
####RECUREDEN RESPETAR LOS NOMBRES EN LAS ESTRUCTURAS Y OPERACIONES############# 
#######################SEGUN DICE EL ENUNCIADO################################## 
################################################################################

##Estas son las cosas que deben respetar

#Nombres de variables Estructura TDA NodoArbolDeLibros:
# - variable "autor" = Nombre de autor
# - variable "libros" = Lista de libros
# - variable "izquierdo" = Subarbol izquierdo
# - variable "derecho" = Subarbol derecho

#Nombres de Operaciones TDA NodoArbolDeLibros:
# - tieneIzquierdo
# - tieneDerecho

#Nombre de variables Estructura TDA ArbolDeLibros:
# - variable "raiz" = Raiz del arbol

#Nombres de Operaciones TDA NodoArbolDelLibros:
# - Todos los nombres en el enunciado
# - estaVacio

#Nombres de funciones TDA Lista:
# - append = Agregar al final
# - len = Longitud de la Lista
# - get = Obtener elemento de posicion de la lista

#from TP_listasArboles_1cuat_2021 import *

################################################################################
#############CARGA DE ARBOL Y GENERACION DE VARIABLES PARA LA PRUEBA############

archivoLibros = open("TP_listasArboles_datosPrueba_2021.csv")

arbolDeLibrosTest = ArbolDeLibros()

librosAutores = {}
librosCargados = set()
for lineaArchivo in archivoLibros:
  lineaArchivo = lineaArchivo[:-1].split(",")
  autor = lineaArchivo[-1]
  librosCargados = librosCargados.union(set(lineaArchivo[:-1]))
  if autor not in librosAutores:
    librosAutores[autor] = set(lineaArchivo[:-1])
  else:
    librosAutores[autor] = librosAutores[autor].union(set(lineaArchivo[:-1]))
  libros = Lista()
  for libro in lineaArchivo[:-1]:
    libros.append(libro)
  arbolDeLibrosTest.insertarLibros(libros, autor)
archivoLibros.close()

################################################################################
################################################################################

arbolDeLibrosTest.treePlot("arbolCompleto")

################################################################################
#######################LISTA DE autores CARGADOS################################

autores = list(librosAutores.keys())
print("Los nombres de los/as autores/as cargados según la entrada son:")
for autor in autores:
  print(autor)

################################################################################
################################################################################

################################################################################
#################PRUEBA DE OPERACION autoresConPalabraEnTitulo##################

print("\n#################PRUEBA DE OPERACION autoresConPalabraEnTitulo##################")
print("\nBúsqueda de palabras que no existen en ningun título de libro:")
palabrasNoEstan = ["puerta","casa","feliz"]
for palabra in palabrasNoEstan:
  print("Autor de libro con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))

print("\nBúsqueda de palabras que están en el árbol en un único título de libro:")
palabrasTituloUnico = ["armar","llano","vigilia"]
for palabra in palabrasTituloUnico:
  print("Autor de libro con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))

print("\nBúsqueda de palabras que están en el árbol en varios títulos de libros:")
palabrasTituloVarios = ["camino","isla","mundo"]
for palabra in palabrasTituloVarios:
  print("Autores de libros con:",palabra,arbolDeLibrosTest.autoresConPalabraEnTitulo(palabra))


################################################################################
################################################################################

################################################################################
######################PRUEBA DE OPERACION buscarLibros##########################

print("\n######################PRUEBA DE OPERACION buscarLibros##########################")
print("\nBúsqueda de autores/as que no existen en el árbol:")
autoresNoEstan = ["Eduardo Sacheri","Victoria Ocampo","Jane Austen"]
for autor in autoresNoEstan:
  listaAutores = Lista()
  listaAutores.append(autor)
  print("Libros de",autor,"en el árbol:",arbolDeLibrosTest.buscarLibros(listaAutores))

print("\nBúsqueda de autores/as que están en el arbol pero no comparten libros:")
autoresConDistintas = ["Julio Cortázar","Roberto Fontanarrosa","Oscar Wilde"]
listaAutores = Lista()
print("\nBuscados de a uno:")
for autor in autoresConDistintas:
  listaActual = Lista()
  listaActual.append(autor)
  print("El/La autor/a",autor,"tiene los libros:",arbolDeLibrosTest.buscarLibros(listaActual))
  listaAutores.append(autor)
print("\nLos libros compartidos por",listaAutores,"son:",arbolDeLibrosTest.buscarLibros(listaAutores))

print("\nBúsqueda con autores/as que comparten libros:")
listaPares = [["Jorge Luis Borges","Paulo Coelho"],
              ["Paulo Coelho","Ben Jonson"],
              ["Craig Russell","Leon Tolstoi"],
              ["Michael Crichton","Arthur Conan Doyle"],
              ["Isabel Allende","Rani Manicka"]]
for par in listaPares:
  listaAutores = Lista()
  for autor in par:
    listaAutores.append(autor)
  print("Los libros compartidos por",listaAutores,"son:",arbolDeLibrosTest.buscarLibros(listaAutores))

################################################################################
################################################################################

################################################################################
###################PRUEBA DE OPERACION cantidadTotalAutores#####################

print("\n###################PRUEBA DE OPERACION cantidadTotalAutores#####################")
print("\nAutores con nombre 'Roberto':")
print("Cantidad de autores ingresados:",len(list(filter(lambda x:"Roberto" in x,autores)))) 
print("Cantidad de autores según el árbol:",arbolDeLibrosTest.cantidadTotalAutores("Roberto")) 

print("\nAutores con el nombre 'Carlos':")
print("Cantidad de autores ingresados:",len(list(filter(lambda x:"Carlos" in x,autores)))) 
print("Cantidad de autores según el árbol:",arbolDeLibrosTest.cantidadTotalAutores("Carlos")) 

print("\nAutoras con el nombre 'Alejandra':")
print("Cantidad de autoras ingresados:",len(list(filter(lambda x:"Alejandra" in x,autores)))) 
print("Cantidad de autoras según el árbol:",arbolDeLibrosTest.cantidadTotalAutores("Alejandra")) 

################################################################################
################################################################################

################################################################################
###############PRUEBA DE OPERACION raizBalanceada###############################

print("\n###############PRUEBA DE OPERACION raizBalanceada###############################")
print("\nBalanceo de la raíz del árbol:",arbolDeLibrosTest.raizBalanceada())

################################################################################
################################################################################

################################################################################
###############PRUEBA DE OPERACION librosEnNivel################################

print("\n###############PRUEBA DE OPERACION librosEnNivel################################")
print("\nLibros en cada nivel del árbol:")
for nivel in range(10):
  print("Libros en nivel:",nivel,"=",arbolDeLibrosTest.librosEnNivel(nivel).len())

################################################################################
################################################################################

################################################################################
###############PRUEBA DE OPERACION autoresConMaslibros##########################

print("\n###############PRUEBA DE OPERACION autoresConMaslibros##########################")
print("\nAutores/as con mayor cantidad de libros:")
for cantidadMinima in range(1,30,5):
  print("Hay",arbolDeLibrosTest.autoresConMasLibros(cantidadMinima),"autores/as con",cantidadMinima,"libros o más")

################################################################################
################################################################################

################################################################################
###################PRUEBA DE OPERACION internosAlfabetico#######################

print("\n###################PRUEBA DE OPERACION internosAlfabetico#######################")
print("\nAutores/as en nodos internos en orden alfabético:")
autores.sort()
print("Todos/as los autores/as ingresados:", autores)
print("Autores/as en nodos internos",arbolDeLibrosTest.internosAlfabetico())

################################################################################
################################################################################

################################################################################
###############PRUEBA DE OPERACION eliminarLibro################################

print("\n###############PRUEBA DE OPERACION eliminarLibro################################")
print("\nEliminamos todos los libros de 'Leon Tolstoi' uno por uno con la operación eliminarLibro:")

print("\nLibros de cada uno/a de los/as autores/as antes de borrar:")
for autor in autores:
  listaInt = Lista()
  listaInt.append(autor)
  librosDeAutor = list(librosAutores[autor])
  librosDeAutorArbol = arbolDeLibrosTest.buscarLibros(listaInt)
  print("El/La autor/a",autor,"tiene",len(librosDeAutor),"libros distintos ingresados según datos de entrada.")
  print("El/La autor/a",autor,"tiene",librosDeAutorArbol.len(),"libros distintos según el árbol.") 

for libro in librosAutores["Leon Tolstoi"]:
  arbolDeLibrosTest.eliminarLibro(libro)

print("\nLibros de cada uno/a de los/as autores/as después de borrar:")
for autor in autores:
  listaInt = Lista()
  listaInt.append(autor)
  librosDeAutor = list(librosAutores[autor])
  librosDeAutorArbol = arbolDeLibrosTest.buscarLibros(listaInt)
  print("El/La autor/a",autor,"tiene",len(librosDeAutor),"libros distintos ingresados según datos de entrada.")
  print("El/La autor/a",autor,"tiene",librosDeAutorArbol.len(),"libros distintos según el árbol.") 

################################################################################
################################################################################

################################################################################
###############PRUEBA DE OPERACION eliminarAutor################################

print("\n###############PRUEBA DE OPERACION eliminarAutor################################")
print("\nEliminamos el autor 'Fiodor Dostoyevski' con eliminarAutor:")

arbolDeLibrosTest.eliminarAutor("Fiodor Dostoyevski")

print("\nLibros de cada uno/a de los/as autores/as después de borrar:")
for autor in autores:
  listaInt = Lista()
  listaInt.append(autor)
  librosDeAutor = list(librosAutores[autor])
  librosDeAutorArbol = arbolDeLibrosTest.buscarLibros(listaInt)
  print("El/La autor/a",autor,"tiene",len(librosDeAutor),"libros distintos ingresados según datos de entrada.")
  print("El/La autor/a",autor,"tiene",librosDeAutorArbol.len(),"libros distintos según el árbol.") 

################################################################################
################################################################################